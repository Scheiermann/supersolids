:mod:`supersolids.functions`
============================

.. py:module:: supersolids.functions

.. autoapi-nested-parse::

   Functions for Potential and initial wave function :math:`\psi_0`



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   supersolids.functions.Resolution
   supersolids.functions.Box



Functions
~~~~~~~~~

.. autoapisummary::

   supersolids.functions.get_meshgrid
   supersolids.functions.get_meshgrid_3d
   supersolids.functions.get_parameters
   supersolids.functions.get_g
   supersolids.functions.g_qf_helper
   supersolids.functions.get_g_qf
   supersolids.functions.get_l_ho
   supersolids.functions.get_alphas
   supersolids.functions.psi_gauss_2d_pdf
   supersolids.functions.psi_gauss_2d
   supersolids.functions.psi_gauss_3d
   supersolids.functions.psi_gauss_1d
   supersolids.functions.psi_pdf
   supersolids.functions.psi_rect
   supersolids.functions.psi_gauss_solution
   supersolids.functions.thomas_fermi_1d
   supersolids.functions.thomas_fermi_2d
   supersolids.functions.thomas_fermi_2d_pos
   supersolids.functions.thomas_fermi_3d
   supersolids.functions.mu_1d
   supersolids.functions.mu_2d
   supersolids.functions.mu_3d
   supersolids.functions.v_harmonic_1d
   supersolids.functions.v_harmonic_2d
   supersolids.functions.v_2d
   supersolids.functions.v_harmonic_3d
   supersolids.functions.get_r_cut
   supersolids.functions.dipol_dipol_interaction
   supersolids.functions.f_kappa
   supersolids.functions.atan_special
   supersolids.functions.func_125
   supersolids.functions.func_124
   supersolids.functions.get_R_rz
   supersolids.functions.get_kappa
   supersolids.functions.density_in_trap
   supersolids.functions.density_in_trap_r
   supersolids.functions.camera_func_r
   supersolids.functions.camera_func_phi
   supersolids.functions.camera_func_z
   supersolids.functions.camera_3d_trajectory
   supersolids.functions.noise_mesh


.. py:class:: Resolution(x: float, y: Optional[float] = None, z: Optional[float] = None)

   Specifies the resolution of the simulation in x, y, z directions (1D, 2D, 3D).


.. py:class:: Box(x0: float, x1: float, y0: Optional[float] = None, y1: Optional[float] = None, z0: Optional[float] = None, z1: Optional[float] = None)

   Specifies the ranges in which the simulation is calculated (1D, 2D or 3D).
   Needs to be given in pairs (x0, x1), (y0, y1), (z0, z1).

   .. method:: lengths(self) -> List[float]

      Calculates the box lengths in the directions available in order [x, y, z]

      :return: List of the box length in the directions available in order [x, y, z]


   .. method:: min_length(self)



.. function:: get_meshgrid(x, y)


.. function:: get_meshgrid_3d(x, y, z)


.. function:: get_parameters(N: int = 10**4, m: float = 164 * constants.u_in_kg, a_s: float = 90.0 * constants.a_0, a_dd: float = 130.0 * constants.a_0, w_x: float = 2.0 * np.pi * 30.0)


.. function:: get_g(N: int, a_s_l_ho_ratio: float)


.. function:: g_qf_helper(m: float = 164 * constants.u_in_kg, a_s: float = 90.0 * constants.a_0, a_dd: float = 130.0 * constants.a_0, w_x: float = 2.0 * np.pi * 30.0)


.. function:: get_g_qf(N: int, a_s_l_ho_ratio: float, epsilon_dd: float)


.. function:: get_l_ho(m: float = 164.0 * constants.u_in_kg, w_x: float = 2.0 * np.pi * 30.0)


.. function:: get_alphas(w_x: float = 2.0 * np.pi * 30.0, w_y: float = 2.0 * np.pi * 30.0, w_z: float = 2.0 * np.pi * 30.0)


.. function:: psi_gauss_2d_pdf(pos, mu=np.array([0.0, 0.0]), var=np.array([[1.0, 0.0], [0.0, 1.0]]))

   Gives values according to gaus dirstribution (2D)
   with meshgrid of x,y as input

   :param pos: stacked meshgrid of an x (1D) and y (1D)
   :param mu: Mean of gauss
   :param var: Variance of gauss

   :param z_mesh: values according to gaus dirstribution (2D)
       with meshgrid of x,y as input


.. function:: psi_gauss_2d(x, y, a: float = 1.0, x_0: float = 0.0, y_0: float = 0.0, k_0: float = 0.0)

   Gaussian wave packet of width a and momentum k_0, centered at x_0

   :param x: mathematical variable

   :param y: mathematical variable

   :param a: Amplitude of pulse

   :param x_0: Mean spatial x of pulse

   :param y_0: Mean spatial y of pulse

   :param k_0: Group velocity of pulse


.. function:: psi_gauss_3d(x, y, z, a_x: float = 1.0, a_y: float = 1.0, a_z: float = 1.0, x_0: float = 0.0, y_0: float = 0.0, z_0: float = 0.0, k_0: float = 0.0)

   Gaussian wave packet of width a and momentum k_0, centered at x_0

   :param x: mathematical variable

   :param y: mathematical variable

   :param z: mathematical variable

   :param a_x: Stretching factor in x direction

   :param a_y: Stretching factor in y direction

   :param a_z: Stretching factor in z direction

   :param x_0: Mean spatial x of pulse

   :param y_0: Mean spatial y of pulse

   :param z_0: Mean spatial z of pulse

   :param k_0: Group velocity of pulse


.. function:: psi_gauss_1d(x, a: float = 1.0, x_0: float = 0.0, k_0: float = 0.0)

   Gaussian wave packet of width a and momentum k_0, centered at x_0

   :param x: mathematical variable

   :param a: Amplitude of pulse

   :param x_0: Mean spatial x of pulse

   :param k_0: Group velocity of pulse


.. function:: psi_pdf(x, loc: float = 0.0, scale: float = 1.0)

   Mathematical function of gauss pulse

   :param x: mathematical variable

   :param loc: Localization of pulse centre

   :param scale: Scale of pulse


.. function:: psi_rect(x, x_min: float = -0.5, x_max: float = 0.5, a: float = 1.0)

   Mathematical function of rectangular pulse
   between x_min and x_max with amplitude a

   :param x: mathematical variable

   :param x_min: Minimum x value of pulse (spatial)

   :param x_max: Maximum x value of pulse (spatial)

   :param a: Amplitude of pulse


.. function:: psi_gauss_solution(x)

   Mathematical function of solution of non-linear Schroedinger for g=0

   :param x: mathematical variable


.. function:: thomas_fermi_1d(x, g: float = 0.0)

   Mathematical function of Thomas-Fermi distribution with coupling constant g

   :param x: mathematical variable

   :param g: coupling constant


.. function:: thomas_fermi_2d(x, y, g: float = 0.0)

   Mathematical function of Thomas-Fermi distribution with coupling constant g

   :param x: mathematical variable

   :param y: mathematical variable

   :param g: coupling constant


.. function:: thomas_fermi_2d_pos(pos, g: float = 0.0)


.. function:: thomas_fermi_3d(x, y, z, g: float = 0.0)

   Mathematical function of Thomas-Fermi distribution with coupling constant g

   :param x: mathematical variable

   :param y: mathematical variable

   :param z: mathematical variable

   :param g: coupling constant


.. function:: mu_1d(g: float = 0.0)


.. function:: mu_2d(g: float = 0.0)


.. function:: mu_3d(g: float = 0.0)


.. function:: v_harmonic_1d(x)


.. function:: v_harmonic_2d(pos, alpha_y: float = 1.0)


.. function:: v_2d(x, y, alpha_y=1.0)


.. function:: v_harmonic_3d(x, y, z, alpha_y: float = 1.0, alpha_z: float = 1.0)


.. function:: get_r_cut(k_mesh: np.ndarray, r_cut: float = 1.0)


.. function:: dipol_dipol_interaction(kx_mesh: float, ky_mesh: float, kz_mesh: float, r_cut: float = 1.0)


.. function:: f_kappa(kappa: np.ndarray, epsilon: float = 10**(-10)) -> float


.. function:: atan_special(x)


.. function:: func_125(kappa: float, alpha_z: float, e_dd: float, epsilon: float = 10**(-10))


.. function:: func_124(kappa: float, e_dd: float, N: float, a_s_l_ho_ratio: float)


.. function:: get_R_rz(kappa: float, e_dd: float, N: int, a_s_l_ho_ratio: float)


.. function:: get_kappa(alpha_z: float, e_dd: float, x_min: float = 3.0, x_max: float = 5.0, res: int = 1000)


.. function:: density_in_trap(x: float, y: float, z: float, R_r: float, R_z: float, g: float = 0.0)


.. function:: density_in_trap_r(r: float, z: float, R_r: float, R_z: float, g: float = 0.0)


.. function:: camera_func_r(frame: int, r_0: float = 10.0, phi_0: float = 45.0, z_0: float = 20.0, r_per_frame: float = 10.0) -> float


.. function:: camera_func_phi(frame: int, r_0: float = 10.0, phi_0: float = 45.0, z_0: float = 20.0, phi_per_frame: float = 10.0) -> float


.. function:: camera_func_z(frame: int, r_0: float = 10.0, phi_0: float = 45.0, z_0: float = 20.0, z_per_frame: float = 10.0) -> float


.. function:: camera_3d_trajectory(frame: int, r_func: Callable = None, phi_func: Callable = None, z_func: Callable = None, r_0: float = 10.0, phi_0: float = 45.0, z_0: float = 20.0) -> Tuple[float, float, float]

   Computes r, phi, z as the components of the camera position
   in the animation for the given frame.
   Depending on, if a callable function is given for the components,
   it is applied to the parameters
   or the start values are used.

   :param frame: Index of the frame in the animation

   :param r_func: r component of the movement of the camera.

   :param phi_func: phi component of the movement of the camera.

   :param z_func: z component of the movement of the camera.

   :param r_0: r component of the starting point of the camera movement.

   :param phi_0: phi component of the starting point of the camera movement.

   :param z_0: z component of the starting point of the camera movement.

   :return: r, phi, z as the components of the camera position
       in the animation for the given frame.


.. function:: noise_mesh(min: float = 0.8, max: float = 1.2, shape: Tuple[int, int, int] = (64, 64, 64)) -> np.ndarray


.. data:: datapoints_exponent
   :annotation: :int = 6

   

