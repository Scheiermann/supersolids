:py:mod:`supersolids.SchroedingerMixture`
=========================================

.. py:module:: supersolids.SchroedingerMixture

.. autoapi-nested-parse::

   Numerical solver for non-linear time-dependent Schrodinger equation (eGPE) for dipolar mixtures.




Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   supersolids.SchroedingerMixture.SchroedingerMixture



Functions
~~~~~~~~~

.. autoapisummary::

   supersolids.SchroedingerMixture.smaller_slice
   supersolids.SchroedingerMixture.get_A_density_total
   supersolids.SchroedingerMixture.get_mu_lhy_integrated_list



.. py:function:: smaller_slice(val0, val1)


.. py:function:: get_A_density_total(density_list)


.. py:function:: get_mu_lhy_integrated_list(func_list)


.. py:class:: SchroedingerMixture(MyBox, Res, max_timesteps, dt, N_list, m_list, a_s_array, a_dd_array, t = 0.0, a_s_factor = 4.0 * np.pi, a_dd_factor = 3.0, nA_max = 100, dt_func = None, w_x = 2.0 * np.pi * 33.0, w_y = 2.0 * np.pi * 80.0, w_z = 2.0 * np.pi * 167.0, imag_time = True, tilt = 0.0, stack_shift = 0.0, mu_arr = None, E = 1.0, V = functions.v_harmonic_3d, V_interaction = None, psi_0_list = [functions.psi_gauss_3d], psi_0_noise_list = [functions.noise_mesh], psi_sol_list = [functions.thomas_fermi_3d], mu_sol_list = [functions.mu_3d], input_path = Path('~/supersolids/results').expanduser())

   Bases: :py:obj:`supersolids.Schroedinger.Schroedinger`

   Implements a numerical solution of the dimensionless time-dependent
   non-linear Schroedinger equation for an arbitrary potential:

   .. math::

      i \partial_t \psi = [&-\frac{1}{2} \nabla ^2
                             + \frac{1}{2} (x^2 + (y \alpha_y)^2 + (z \alpha_z)^2) \\
                            &+ g |\psi|^2  + g_{qf} |\psi|^3 + U_{dd}] \psi \\

   With :math:`U_{dd} = \mathcal{F}^{-1}(\mathcal{F}(H_{pot} \psi) \epsilon_{dd} g (3 (k_z / k)^2 - 1))`

   The split operator method with the Trotter-Suzuki approximation
   for the commutator relation (:math:`H = H_{pot} + H_{kin}`) is used.
   Hence the accuracy is proportional to :math:`dt^4`
   The approximation is needed because of the Baker-Campell-Hausdorff formula.

   m is the atomic mass
   :math:`C_{d d}=\mu_{0} \mu^{2}` sets the strength of the dipolar interaction
   with :math:`\mu=9.93 \mu_{\mathrm{B}}` the magnetic dipole moment of
   :math:`^{162}\mathrm{Dy}`.

   We use dipolar units, obtained from the characteristic dipolar length
   :math:`r_{0}= \frac{m C_{d d}}{4 \pi \hbar^{2}}  = 387.672168  a_0`
   and the dipolar scale of energy :math:`\epsilon_{0} = \frac{\hbar^{2}}{m r_{0}^{2}}`


   .. py:method:: convert_all_to_numpy()


   .. py:method:: copy_with_all_numpy()


   .. py:method:: func_energy(u)

      (V_+)**5/2 + (V_-)**5/2



   .. py:method:: func_f_symb(u, func, eta_a, eta_b)


   .. py:method:: mu_lhy_integrand(u, eta_dVdn)


   .. py:method:: eta_dVdna(lam, eta_aa, eta_bb, eta_ab)


   .. py:method:: eta_dVdnb(lam, eta_aa, eta_bb, eta_ab)


   .. py:method:: get_mu_lhy_list(density_list)


   .. py:method:: get_energy_lhy(density_list)


   .. py:method:: save_psi_val(input_path, filename_steps, steps_format, frame, arr_list=None)


   .. py:method:: use_summary(summary_name = None)


   .. py:method:: load_summary(input_path, steps_format, frame, summary_name = 'SchroedingerMixtureSummary_', host=None)


   .. py:method:: load_mu(filename_mu_a = 'interpolator_mu_a.pkl', filename_mu_b = 'interpolator_mu_b.pkl')


   .. py:method:: load_lhy(filename_lhy = 'interpolator_lhy_energy.pkl')


   .. py:method:: energy_density_interaction_explicit(density_list)


   .. py:method:: energy_density_interaction(density_list)


   .. py:method:: get_E()


   .. py:method:: get_E_pot(density_list, dV = None)


   .. py:method:: get_E_kin(dV = None)


   .. py:method:: get_mu_explicit(psi_previous_list)


   .. py:method:: get_E_explicit()


   .. py:method:: energy(density_list, mu_lhy_list)

      Input psi_1, psi_2 need to be normalized.
      density1 and density2 need to be build by the normalized psi_1, psi_2.



   .. py:method:: get_density_list(jit = True, cupy_used = False)


   .. py:method:: get_center_of_mass(Mx0 = None, Mx1 = None, My0 = None, My1 = None, Mz0 = None, Mz1 = None, p = 1.0)

      Calculates the center of mass of the System.



   .. py:method:: get_parity(axis = None, Mx0 = None, Mx1 = None, My0 = None, My1 = None, Mz0 = None, Mz1 = None)


   .. py:method:: check_N()

              Calculates :math:`N_i = \int \mathcal{d}
      ec{r} |\psi_{i}(r)|^2`
              Returns [N_1, N_2, N]
              


   .. py:method:: distmat(a, index)


   .. py:method:: get_contrast_old(axis = 2, Mx0 = None, Mx1 = None, My0 = None, My1 = None, Mz0 = None, Mz1 = None)


   .. py:method:: get_contrast_old_smart(axis = 2, Mx0 = None, Mx1 = None, My0 = None, My1 = None, Mz0 = None, Mz1 = None)


   .. py:method:: on_edge(indices, Mx0 = None, Mx1 = None, My0 = None, My1 = None, Mz0 = None, Mz1 = None)


   .. py:method:: get_contrast(number_of_peaks, prob_min_start, prob_step = 0.01, prob_min_edge = 0.015, region_threshold = 100)


   .. py:method:: get_polarization(input_path, filename_steps, steps_format, numerator_cut_off, divisor_cut_off, frame)

      Calculates the polarization of a two component mixture: P = density2/density1.

      :param divisor_cut_off: Cutoff for density1 to prohibit division by 0.

      :param frame: Frame number of the npz to save to.



   .. py:method:: get_U_dd(density_list)

      Calculates :math:`U_{dd, ij} = \mathcal{F}^{-1}(\mathcal{F}(S_{ij} |\psi_{j}|^{2}) V_{k})`
      with :math: `V_{k} = epsilon_{dd} g (3 (k_z / k)^2 - 1)`,
      :math: `S_{ij} = exp{-ikM}` and
      :math: `M_{ij} = stack_shift * \sigma_{x}` with :math: `\sigma_{x}` is the x-Pauli matrix



   .. py:method:: get_U_dd_list(density_list)


   .. py:method:: get_H_pot(terms, split_step = 0.5)


   .. py:method:: get_H_pot_exponent_terms(dipol_term, contact_interaction, mu_lhy)


   .. py:method:: split_operator_pot(split_step = 0.5, jit = True, cupy_used = False)


   .. py:method:: split_operator_kin()


   .. py:method:: normalize_psi_val()


   .. py:method:: time_step(numba_used, cupy_used)

      Evolves System according Schr√∂dinger Equations by using the
      split operator method with the Trotter-Suzuki approximation.




