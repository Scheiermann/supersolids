:mod:`supersolids.Schroedinger`
===============================

.. py:module:: supersolids.Schroedinger

.. autoapi-nested-parse::

   Numerical solver for non-linear time-dependent Schrodinger equation.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   supersolids.Schroedinger.Schroedinger



.. py:class:: Schroedinger(N: int, Box: functions.Box, Res: functions.Resolution, max_timesteps: int, dt: float, dt_func: Optional[Callable] = None, g: float = 0.0, g_qf: float = 0.0, w_y: float = 2.0 * np.pi * 80.0, w_z: float = 2.0 * np.pi * 167.0, a_s: float = 85.0 * constants.a_0, e_dd: float = 1.0, imag_time: bool = True, mu: float = 1.1, E: float = 1.0, psi_0: Callable = functions.psi_gauss_3d, V: Optional[Callable] = functions.v_harmonic_3d, V_interaction: Optional[Callable] = None, psi_sol: Optional[Callable] = functions.thomas_fermi_3d, mu_sol: Optional[Callable] = functions.mu_3d, psi_0_noise: np.ndarray = functions.noise_mesh)

   Implements a numerical solution of the dimensionless time-dependent
   non-linear Schrodinger equation for an arbitrary potential:

   .. math::

      i \partial_t \psi = [&-\frac{1}{2} \nabla ^2
                             + \frac{1}{2} (x^2 + (y \alpha_y)^2 + (z \alpha_z)^2) \\
                            &+ g |\psi|^2  + g_{qf} |\psi|^3 + U_{dd}] \psi \\

   With :math:`U_{dd} =  \mathcal{F}^{-1}(\mathcal{F}(H_{pot} \psi) \epsilon_{dd} g ((3 k_z / k^2) - 1))`

   The split operator method with the Trotter-Suzuki approximation
   for the commutator relation (:math:`H = H_{pot} + H_{kin}`) is used.
   Hence the accuracy is proportional to :math:`dt^4`
   The approximation is needed because of the Baker-Campell-Hausdorff formula.

   .. method:: get_density(self, p: float = 2.0) -> np.ndarray

      Calculates :math:`|\psi|^p` for 1D, 2D or 3D (depending on self.dim).

      :param p: Exponent of :math:`|\psi|`. Use p=2.0 for density.

      :return: :math:`|\psi|^p`


   .. method:: get_norm(self, p: float = 2.0) -> float

      Calculates :math:`\int |\psi|^p \mathrm{dV}` for 1D, 2D or 3D
      (depending on self.dim). For p=2 it is the 2-norm.

      :param p: Exponent of :math:`|\psi|`. Use p=2.0 for density.

      :return: :math:`\int |\psi|^p \mathrm{dV}`


   .. method:: get_norm_trapez(self, func_val: Callable) -> float

      Calculates :math:`\int |\psi|^p \mathrm{dV}` for 1D, 2D or 3D
      (depending on self.dim) by using the trapez rule.

      For 1D: :math:`h (f(a) + f(a+h)) / 2`

      For 2D: :math:`h (f(a, b) + f(a+h, b) + f(a, b+h) + f(a+h, b+h)) / 2`

      For 3D there are 8 entries in the same manner
      :math:`(a, b, c) ... (a+h, b+h, c+h)`

      :param func_val: Grid sampled values of the function to integrate.

      :return: :math:`\int |\psi|^p \mathrm{dV}` according to trapez rule


   .. method:: time_step(self) -> None

      Evolves System according Schr√∂dinger Equations by using the
      split operator method with the Trotter-Suzuki approximation.



